#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif
#include <Python.h>
#include "structmember.h"

#include "geneticOpt.h"
#include "stdmath.h"
#include "stdgen.h"
#include "realinitialization.h"
#include "realselection.h"
#include "realcrossover.h"
#include "realmutation.h"
#include "realreplacement.h"

static PyMethodDef realGeneticModelMethods[] =
{

    {NULL, NULL, 0, NULL},
};

static PyMemberDef realGeneticModelObjectMembers[] =
{
    {"fitFunction", T_OBJECT, offsetof(realGeneticModelObject, fitFunction), 0,
    "Pointer to a Python fitness function."},

    {"objType", T_NONE, offsetof(realGeneticModelObject, objType), 0,
    "Objective type (minimization or maximization)."},

    {"individual", T_NONE, offsetof(realGeneticModelObject, individual), 0,
    "Individuals of the population generated by the genetic algorithm."},

    {"population", T_NONE, offsetof(realGeneticModelObject, population), 0,
    "Population settings."},

    {"chromosome", T_NONE, offsetof(realGeneticModelObject, chromosome), 0,
    "Chromosome settings."},

    {"initialization", T_NONE, offsetof(realGeneticModelObject, initialization), 0,
    "Initialization model."},

    {"selection", T_NONE, offsetof(realGeneticModelObject, selection), 0,
    "Selection model."},

    {"crossover", T_NONE, offsetof(realGeneticModelObject, crossover), 0,
    "Crossover model."},

    {"mutation", T_NONE, offsetof(realGeneticModelObject, mutation), 0,
    "Mutation model."},

    {"replacement", T_NONE, offsetof(realGeneticModelObject, replacement), 0,
    "Replacement model."},

    {"seed", T_UINT, offsetof(realGeneticModelObject, replacement), 0,
    "Seed used by the random number generator."},

    {NULL},
};

static PyTypeObject realGeneticModelType =
{
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "geneticOpt.realCodificationModel",
    .tp_doc = "Genetic algorithms with real number codification.",
    .tp_basicsize = sizeof(realGeneticModelObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = defaultNewRealGeneticModel,
    .tp_init = (initproc) usrInitRealGeneticModel,
    .tp_dealloc = (destructor) realGeneticModelDealloc,
    .tp_methods = realGeneticModelMethods,
    .tp_members = realGeneticModelObjectMembers,
};

static PyModuleDef geneticOptModule =
{
    PyModuleDef_HEAD_INIT,
    .m_name = "geneticOpt",
    .m_doc = "Genetic Algorithms for Python.",
    .m_size = -1,
};

static PyObject * defaultNewRealGeneticModel(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    realGeneticModelObject *self;

    self = (realGeneticModelObject *) type->tp_alloc(type, 0);

    if(self != NULL)
    {
        self->fitFunction = NULL;

        self->objType = undef;

        self->individual = NULL;

        self->population.maxGenerations = 0;
        self->population.size = 0;
        self->population.totalFamilies = 0;
        self->population.totalParents = 0;
        self->population.totalChildren = 0;
        self->population.maxIndividuals = 0;

        self->chromosome.type = real;
        self->chromosome.length = 0;
        self->chromosome.infLimit = NULL;
        self->chromosome.supLimit = NULL;

        self->initialization.type = realInit_type_undef;
        self->initialization.function = NULL;

        self->selection.type = realSelect_type_undef;
        self->selection.function = NULL;
        self->selection.tourModel.function = NULL;
        self->selection.tourModel.tourGroup = NULL;
        self->selection.tourModel.tourSize = 0;

        self->crossover.type = realCross_type_undef;
        self->crossover.function = NULL;
        self->crossover.nPoint = 0;
        self->crossover.prob = 0;
        self->crossover.sepLimits = NULL;

        self->mutation.type = realMut_type_undef;
        self->mutation.function = NULL;
        self->mutation.prob = 0;
        self->mutation.alleleMutProb = 0;
        self->mutation.limit = NULL;

        self->replacement.type = realRepl_type_undef;
        self->replacement.function = NULL;
        self->replacement.srcPopOrdFunction = NULL;

        self->seed = 0;
    }

    return (PyObject *) self;
}

static int usrInitRealGeneticModel(realGeneticModelObject *self, PyObject *args, PyObject *kwds)
{
    char *initTypeStr, *selectionTypeStr, *crossoverTypeStr, *mutationTypeStr, *replacementTypeStr;

    static char *kwlist[] =
    {
        "maxGenerations", "size", "totalFamilies", "totalParents", "totalChildren",
        "chromosomeLength",
        "initType",
        "selectionType",
        "crossoverType", "crossoverProb",
        "mutationType", "mutationProb", "alleleMutationProb",
        "replacementType",
        NULL
    };

    if(!PyArg_ParseTupleAndKeywords(args, kwds, "|IIIIIIsssdsdds", kwlist,
    &(self->population.maxGenerations), &(self->population.size), &(self->population.totalFamilies), &(self->population.totalParents), &(self->population.totalChildren),
    &(self->chromosome.length),
    &initTypeStr,
    &selectionTypeStr,
    &crossoverTypeStr, &(self->crossover.prob),
    &mutationTypeStr, &(self->mutation.prob), &(self->mutation.alleleMutProb),
    &replacementTypeStr))
    {
        return -1;
    }

    //Set Population settings

    //Set Chromosome settings

    //Set Init Settings

    //Set Selection Settings

    //Set Crossover settings

    //Set Mutation Settings

    //Set replacement settings

    return 0;
}

static void realGeneticModelDealloc(realGeneticModelObject *self)
{

}

static PyObject * realGeneticModelSolver(PyObject *self, PyObject *Py_UNUSED(ignored))
{

}

PyMODINIT_FUNC PyInit_geneticOpt(void)
{
    PyObject *m;

    //Verify if types are ready and well defined
    if(PyType_Ready(&realGeneticModelType) < 0)
    {
        return NULL;
    }

    //Create module
    m = PyModule_Create(&geneticOptModule);
    if(m == NULL)
    {
        return NULL;
    }

    //Add the error object to the geneticOpt module
    geneticError = PyErr_NewException("geneticOpt.geneticError", NULL, NULL);
    Py_XINCREF(geneticError);
    if(PyModule_AddObject(m, "geneticError", geneticError) < 0)
    {
        Py_XDECREF(geneticError);
        Py_CLEAR(geneticError);
        Py_DECREF(m);
        return NULL;
    }

    //Add Objects
    Py_INCREF(&realGeneticModelType);
    if(PyModule_AddObject(m, "realCodificationModel", (PyObject *) &realGeneticModelType) < 0)
    {
        Py_DECREF(&realGeneticModelType);
        Py_DECREF(m);
        return NULL;
    }
}
