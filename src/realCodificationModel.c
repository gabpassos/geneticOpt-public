#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif
#include <Python.h>
#include "structmember.h"

//USED ONLY IN MODEL VERIFICATION - REMOVE IF VERIFICATION FUNCTIONS ARE MOVED TO A EXCLUSIVE SRC FILE
#include <stdlib.h>
#include <string.h>

#include "realCodificationModel.h"
#include "stdmath.h"
#include "stdgen.h"
#include "realinitialization.h"
#include "realselection.h"
#include "realcrossover.h"
#include "realmutation.h"
#include "realreplacement.h"

static PyMethodDef realGeneticModelMethods[] =
{
    {"Solve", (PyCFunction) realGeneticModelSolver, METH_NOARGS,
    "Solves the genetic model."},
    {NULL, NULL, 0, NULL},
};

static PyMemberDef realGeneticModelObjectMembers[] =
{
    {"fitFunction", T_OBJECT, offsetof(realGeneticModelObject, fitFunction), 0,
    "Pointer to a Python fitness function."},

    {"objType", T_NONE, offsetof(realGeneticModelObject, objType), 0,
    "Objective type (minimization or maximization)."},

    {"individual", T_NONE, offsetof(realGeneticModelObject, individual), 0,
    "Individuals of the population generated by the genetic algorithm."},

    {"population", T_NONE, offsetof(realGeneticModelObject, population), 0,
    "Population settings."},

    {"chromosome", T_NONE, offsetof(realGeneticModelObject, chromosome), 0,
    "Chromosome settings."},

    {"initialization", T_NONE, offsetof(realGeneticModelObject, initialization), 0,
    "Initialization model."},

    {"selection", T_NONE, offsetof(realGeneticModelObject, selection), 0,
    "Selection model."},

    {"crossover", T_NONE, offsetof(realGeneticModelObject, crossover), 0,
    "Crossover model."},

    {"mutation", T_NONE, offsetof(realGeneticModelObject, mutation), 0,
    "Mutation model."},

    {"replacement", T_NONE, offsetof(realGeneticModelObject, replacement), 0,
    "Replacement model."},

    {"seed", T_UINT, offsetof(realGeneticModelObject, replacement), 0,
    "Seed used by the random number generator."},

    {NULL},
};

static PyTypeObject realGeneticModelType =
{
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "geneticOpt.realCodificationModel",
    .tp_doc = "Genetic algorithms with real number codification.",
    .tp_basicsize = sizeof(realGeneticModelObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = defaultNewRealGeneticModel,
    .tp_init = (initproc) usrInitRealGeneticModel,
    .tp_dealloc = (destructor) realGeneticModelDealloc,
    .tp_methods = realGeneticModelMethods,
    .tp_members = realGeneticModelObjectMembers,
};

static PyModuleDef geneticOptModule =
{
    PyModuleDef_HEAD_INIT,
    .m_name = "geneticOpt",
    .m_doc = "Genetic Algorithms for Python.",
    .m_size = -1,
};

static PyObject * defaultNewRealGeneticModel(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    realGeneticModelObject *self;

    self = (realGeneticModelObject *) type->tp_alloc(type, 0);

    if(self != NULL)
    {
        self->fitFunction = NULL;

        self->objType = obj_type_undef;

        self->individual = NULL;

        self->population.maxGenerations = 0;
        self->population.size = 0;
        self->population.totalFamilies = 0;
        self->population.totalParents = 0;
        self->population.childrensPerFamily = 0;
        self->population.totalChildren = 0;
        self->population.maxIndividuals = 0;

        self->chromosome.type = real;
        self->chromosome.length = 0;
        self->chromosome.infLimit = NULL;
        self->chromosome.supLimit = NULL;

        self->initialization.type = realInit_type_undef;
        self->initialization.function = NULL;

        self->selection.type = realSelect_type_undef;
        self->selection.function = NULL;
        self->selection.tourModel.function = NULL;
        self->selection.tourModel.tourGroup = NULL;
        self->selection.tourModel.tourSize = 0;

        self->crossover.type = realCross_type_undef;
        self->crossover.function = NULL;
        self->crossover.nPoint = 0;
        self->crossover.prob = 0;
        self->crossover.sepLimits = NULL;

        self->mutation.type = realMut_type_undef;
        self->mutation.function = NULL;
        self->mutation.prob = 0;
        self->mutation.alleleMutProb = 0;
        self->mutation.limit = NULL;

        self->replacement.type = realRepl_type_undef;
        self->replacement.function = NULL;
        self->replacement.srcPopOrdFunction = NULL;

        self->seed = 0;
    }

    return (PyObject *) self;
}

static int usrInitRealGeneticModel(realGeneticModelObject *self, PyObject *args, PyObject *kwds)
{
    char *objTypeStr, *initTypeStr, *selectionTypeStr, *crossoverTypeStr, *mutationTypeStr, *replacementTypeStr;
    PyObject *fitFunction = NULL;

    static char *kwlist[] =
    {
        "objective", "fitFunction",
        "maxGenerations", "populationSize", "totalFamilies", "totalParents", "childrensPerFamily",
        "chromosomeLength",
        "initType",
        "selectionType",
        "crossoverType", "crossoverProb",
        "mutationType", "mutationProb", "alleleMutationProb",
        "replacementType",
        NULL
    };

    if(!PyArg_ParseTupleAndKeywords(args, kwds, "|sOIIIIIIsssdsdds", kwlist,
    &objTypeStr, &fitFunction,
    &(self->population.maxGenerations), &(self->population.size), &(self->population.totalFamilies), &(self->population.totalParents), &(self->population.childrensPerFamily),
    &(self->chromosome.length),
    &initTypeStr,
    &selectionTypeStr,
    &crossoverTypeStr, &(self->crossover.prob),
    &mutationTypeStr, &(self->mutation.prob), &(self->mutation.alleleMutProb),
    &replacementTypeStr))
    {
        return -1;
    }

    //Set Objective Settings
    if(!objectiveVerifySettings(self, objTypeStr, fitFunction))
    {
        return -1;
    }

    //Set Population settings
    if(!populationModelVerifySettings(&(self->population)))
    {
        return -1;
    }

    //Set Chromosome settings
    if(!chromosomeModelVerifySettings(&(self->chromosome)))
    {
        return -1;
    }

    //Set Init Settings
    if(!realInitializationModelVerifySettings(&(self->initialization), initTypeStr))
    {
        return -1;
    }

    //Set Selection Settings
    if(!realSelectionModelVerifySettings(&(self->selection), selectionTypeStr, &(self->population), self->objType))
    {
        return -1;
    }

    //Set Crossover settings
    if(!realCrossoverModelVerifySettings(&(self->crossover), &(self->chromosome), crossoverTypeStr))
    {
        return -1;
    }

    //Set Mutation Settings
    if(!realMutationModelVerifySettings(&(self->mutation), &(self->chromosome), mutationTypeStr))
    {
        return -1;
    }

    //Set replacement settings
    if(!realReplacementModelVerifySettings(&(self->replacement), replacementTypeStr, self->objType))
    {
        return -1;
    }

    return 0;
}

static void realGeneticModelDealloc(realGeneticModelObject *self)
{
    int i;

    Py_XDECREF(self->fitFunction);

    if(self->individual != NULL)
    {
        for(i = 0; i < self->population.size; i++)
        {
            free(self->individual[i].gene);
        }
        free(self->individual);
    }

    free(self->chromosome.infLimit);
    free(self->chromosome.supLimit);

    free(self->selection.tourModel.tourGroup);

    if(self->crossover.sepLimits != NULL)
    {
        for(i = 0; i < self->crossover.nPoint; i++)
        {
            free(self->crossover.sepLimits[i]);
        }
        free(self->crossover.sepLimits);
    }

    if(self->mutation.limit != NULL)
    {
        for(i = 0; i < self->chromosome.length; i++)
        {
            free(self->mutation.limit[i]);
        }
        free(self->mutation.limit);
    }

    Py_TYPE(self)->tp_free((PyObject *) self);
}

static PyObject * realGeneticModelSolver(realGeneticModelObject *self, PyObject *Py_UNUSED(ignored))
{
    double soma;

    int i, j, g;
    realChromosome ***parents;
    realChromosome totalPopulation[self->population.maxIndividuals];

    PyObject *chromosome = NULL;
    PyObject *fitArg = NULL;
    PyObject *fitValue = NULL;

    //Memory allocation to totalPopulation gene
    for(i = 0; i < self->population.maxIndividuals; i++)
    {
        totalPopulation[i].gene = (double *) malloc(self->chromosome.length*sizeof(double));
        if(totalPopulation[i].gene == NULL)
        {
            PyErr_NoMemory();
            return NULL;
        }
    }

    //Memory allocation to the population individuals
    self->individual = (realChromosome *) malloc(self->population.size*sizeof(realChromosome));
    if(self->individual == NULL)
    {
        PyErr_NoMemory();
        return NULL;
    }

    for(i = 0; i < self->population.size; i++)
    {
        self->individual[i].gene = (double *) malloc(self->chromosome.length*sizeof(double));
        if(self->individual[i].gene == NULL)
        {
            PyErr_NoMemory();
            return NULL;
        }
    }

    parents = (realChromosome ***) malloc((self->population.totalFamilies)*sizeof(realChromosome **));
    if(parents == NULL)
    {
        PyErr_NoMemory();
        return NULL;
    }
    for(i = 0; i < self->population.totalFamilies; i++)
    {
        parents[i] = (realChromosome **) malloc((self->population.totalParents)*sizeof(realChromosome *));
        if(parents == NULL)
        {
            PyErr_NoMemory();
            return NULL;
        }
    }

    //Initialization of the Python tuple args for fitFunction
    chromosome = PyTuple_New(self->chromosome.length);
    if(chromosome == NULL)
    {
        return NULL;
    }

    fitArg = PyTuple_New(1);
    if(fitArg == NULL)
    {
        Py_DECREF(chromosome);
        return NULL;
    }

    PyTuple_SetItem(fitArg, 0, chromosome);

    srand(time(NULL));

    //Initialization
    self->initialization.function(self->individual, &(self->population), &(self->chromosome));

    //Evaluate population
    for(i = 0; i < self->population.size; i++)
    {
        for(j = 0; j < self->chromosome.length; j++)
        {
            PyTuple_SetItem(chromosome, j, PyFloat_FromDouble(self->individual[i].gene[j]));
        }

        fitValue = PyObject_CallObject(self->fitFunction, fitArg);
        if(fitValue == NULL)
        {
            Py_DECREF(chromosome);
            Py_DECREF(fitArg);
            return NULL;
        }

        self->individual[i].fit = PyFloat_AsDouble(fitValue);
        self->individual[i].evaluated = True;

        Py_DECREF(fitValue);

        soma = 0;
        for(j = 0; j < self->chromosome.length; j++)
        {
            soma += self->individual[i].gene[j]*self->individual[i].gene[j];
        }
        self->individual[i].fit = soma;
        self->individual[i].evaluated = True;
    }

    for(g = 1; g <= self->population.maxGenerations; g++)
    {
        //Selection
        self->selection.function(parents, self->individual, &(self->population), &(self->selection));

        //Crossover
        self->crossover.function(parents, totalPopulation, &(self->crossover), &(self->population), &(self->chromosome), g);

        //Mutation
        self->mutation.function(totalPopulation, &(self->population), &(self->mutation), &(self->chromosome));

        //Evaluate offsprings
        for(i = 0; i < self->population.totalChildren; i++)
        {
            for(j = 0; j < self->chromosome.length; j++)
            {
                PyTuple_SetItem(chromosome, j, PyFloat_FromDouble(totalPopulation[i].gene[j]));
            }

            fitValue = PyObject_CallObject(self->fitFunction, fitArg);
            if(fitValue == NULL)
            {
                Py_DECREF(chromosome);
                Py_DECREF(fitValue);
                return NULL;
            }

            totalPopulation[i].fit = PyFloat_AsDouble(fitValue);
            totalPopulation[i].evaluated = True;

            Py_DECREF(fitValue);
        }

        //Complete totalPopulation with original individuals
        for(i = self->population.totalChildren, j = 0; i < self->population.maxIndividuals; i++, j++)
        {
            copyRealChromosome(&totalPopulation[i], &(self->individual)[j], &(self->chromosome));
        }

        //Replacement
        self->replacement.function(self->individual, totalPopulation, &(self->population), &(self->replacement), &(self->chromosome));
    }

    //Retornar NULL em principio;
    Py_INCREF(Py_None);
    return Py_None;
}

static boolean objectiveVerifySettings(realGeneticModelObject *self, char *objTypeStr, PyObject *fitFunction)
{
    if(strcmp(objTypeStr, "min") == 0)
    {
        self->objType = min;
    }

    else if (strcmp(objTypeStr, "max") == 0)
    {
        self->objType = max;
    }

    else
    {
        PyErr_SetString(geneticError, "The objective type provided cannot be recognized.");
        return False;
    }

    if(!PyCallable_Check(fitFunction))
    {
        PyErr_SetString(geneticError, "fitFunction must be callable.");
        return False;
    }

    Py_INCREF(fitFunction);
    Py_XDECREF(self->fitFunction);
    self->fitFunction = fitFunction;

    return True;
}

static boolean populationModelVerifySettings(populationData *population)
{
    if(population->maxGenerations <= 0)
    {
        PyErr_SetString(geneticError, "maxGeneration must be an integer greater than zero.");
        return False;
    }

    else if(population->size <= 0)
    {
        PyErr_SetString(geneticError, "populationSize must be an integer greater than zero.");
        return False;
    }

    else if(population->totalFamilies <= 0)
    {
        PyErr_SetString(geneticError, "totalFamilies must be an integer greater than zero.");
        return False;
    }

    else if(population->totalParents < 2)
    {
        PyErr_SetString(geneticError, "totalParents must be an integer greater than or equal to two.");
        return False;
    }

    else if(population->childrensPerFamily < 2)
    {
        PyErr_SetString(geneticError, "childrensPerFamily must be an integer greater than or equal to two.");
        return False;
    }

    population->maxIndividuals = population->size + (population->totalFamilies)*(population->childrensPerFamily);
    population->totalChildren = (population->totalFamilies)*(population->childrensPerFamily);

    return True;
}

static boolean chromosomeModelVerifySettings(chromosomeData *chromosome)
{
    int i;

    if(chromosome->length <= 0)
    {
        PyErr_SetString(geneticError, "chromosomeLength must be an integer greater than zero.");
        return False;
    }

    chromosome->infLimit = (double *) malloc(chromosome->length*sizeof(double));
    if(chromosome->infLimit == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    chromosome->supLimit = (double *) malloc(chromosome->length*sizeof(double));
    if(chromosome->supLimit == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    for(i = 0; i < chromosome->length; i++)
    {
        chromosome->infLimit[i] = - DEFAULT_CHROM_LIMIT;
        chromosome->supLimit[i] = DEFAULT_CHROM_LIMIT;
    }

    return True;
}

static boolean realInitializationModelVerifySettings(realInitializationModel *initialization, char *initTypeStr)
{
    if(strcmp(initTypeStr, "uniformRandom") == 0)
    {
        initialization->type = realUniformRandomInitType;
        initialization->function = realUniformRandomInit;
    }

    else
    {
        PyErr_SetString(geneticError, "The initType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean realSelectionModelVerifySettings(realSelectionModel *selection, char *selectionTypeStr, populationData *population, objective obj)
{
    if(strcmp(selectionTypeStr, "tournament") == 0)
    {
        if(population->totalParents == 2)
        {
            selection->type = realTwoParentsTournamentSelectionType;
            selection->function = realTwoParentsTournamentSelection;
        }

        else
        {
            selection->type = realnParentsTournamentSelectionType;
            selection->function = realnParentsTournamentSelection;
        }

        selection->tourModel.tourSize = 2;
        selection->tourModel.tourGroup = (int *) malloc(2*sizeof(int));
        if(selection->tourModel.tourGroup == NULL)
        {
            PyErr_NoMemory();
            return False;
        }

        if(obj == min)
        {
            selection->tourModel.function = minTournament;
        }

        else
        {
            selection->tourModel.function = maxTournament;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The selectionType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean realCrossoverModelVerifySettings(realCrossoverModel *crossover, chromosomeData *chromosome, char *crossoverTypeStr)
{
    int i;
    double ratio;

    if(crossover->prob < 0 || crossover->prob > 1)
    {
        PyErr_SetString(geneticError, "The crossoverProb must be a double in the [0,1] interval.");
        return False;
    }

    if(strcmp(crossoverTypeStr, "1-Point") == 0)
    {
        crossover->type = realOnePointCrossoverType;
        crossover->function = realOnePointCrossover;
        crossover->nPoint = 1;

        if(!verifyChromLengthWithnPoint(chromosome->length, 1))
        {
            return False;
        }
    }

    else if(strcmp(crossoverTypeStr, "2-Point") == 0)
    {
        crossover->type = realTwoPointCrossoverType;
        crossover->function = realTwoPointCrossover;
        crossover->nPoint = 2;

        if(!verifyChromLengthWithnPoint(chromosome->length, 2))
        {
            return False;
        }
    }

    else if(strcmp(crossoverTypeStr, "3-Point") == 0)
    {
        crossover->type = realThreePointCrossoverType;
        crossover->function = realThreePointCrossover;
        crossover->nPoint = 3;

        if(!verifyChromLengthWithnPoint(chromosome->length, 3))
        {
            return False;
        }
    }

    else if(strcmp(crossoverTypeStr, "n-Point") == 0)
    {
        crossover->type = realnPointCrossoverType;
        crossover->function = realnPointCrossover;
        crossover->nPoint = 4;

        if(!verifyChromLengthWithnPoint(chromosome->length, 4))
        {
            return False;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The crossoverType provided cannot be recognized.");
        return False;
    }

    crossover->sepLimits = (int **) malloc((crossover->nPoint)*sizeof(int *));
    if(crossover->sepLimits == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    ratio = (chromosome->length)/(crossover->nPoint);

    for(i = 0; i < crossover->nPoint; i++)
    {
        crossover->sepLimits[i] = (int *) malloc(2*sizeof(int));

        if(crossover->sepLimits[i] == NULL)
        {
            PyErr_NoMemory();
            return False;
        }

        crossover->sepLimits[i][0] = (unsigned int) i*ratio;
        crossover->sepLimits[i][1] = (unsigned int) (i + 1)*ratio;
    }

    return True;
}

static boolean realMutationModelVerifySettings(realMutationModel *mutation, chromosomeData *chromosome, char *mutationTypeStr)
{
    int i;

    if(mutation->prob < 0 || mutation->prob > 1)
    {
        PyErr_SetString(geneticError, "The mutationProb must be a double in the [0,1] interval.");
        return False;
    }

    if(mutation->alleleMutProb < 0 || mutation->alleleMutProb > 1)
    {
        PyErr_SetString(geneticError, "The alleleMutProb must be a double in the [0,1] interval.");
        return False;
    }

    mutation->limit = (double **) malloc((chromosome->length)*sizeof(double *));
    if(mutation->limit == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    for(i = 0; i < chromosome->length; i++)
    {
        mutation->limit[i] = (double *) malloc(2*sizeof(double));
        if(mutation->limit[i] == NULL)
        {
            PyErr_NoMemory();
            return False;
        }
    }

    if(strcmp(mutationTypeStr, "totalUniformRandom") == 0)
    {
        mutation->type = realTotalUniformRandomMutationType;
        mutation->function = realTotalUniformRandomMutation;

        for(i = 0; i < chromosome->length; i++)
        {
            mutation->limit[i][0] = - DEFAULT_CHROM_LIMIT;
            mutation->limit[i][1] = DEFAULT_CHROM_LIMIT;
        }
    }

    else if(strcmp(mutationTypeStr, "uniformRandom") == 0)
    {
        mutation->type = realUniformRandomMutationType;
        mutation->function = realUniformRandomMutation;

        for(i = 0; i < chromosome->length; i++)
        {
            mutation->limit[i][0] = - DEFAULT_UNIFORMMUT_LIMIT;
            mutation->limit[i][1] = DEFAULT_UNIFORMMUT_LIMIT;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The mutationType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean realReplacementModelVerifySettings(realReplacementModel *replacement, char *replacementTypeStr, objective obj)
{
    if(strcmp(replacementTypeStr, "elitist") == 0)
    {
        replacement->type = realElitistReplacementType;
        replacement->function = realElitistReplacement;

        if(obj == min)
        {
            replacement->srcPopOrdFunction = realMinimizationCompare;
        }

        else
        {
            replacement->srcPopOrdFunction = realMaximizationCompare;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The replacementType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean verifyChromLengthWithnPoint(unsigned int chromLength, unsigned int nPoint)
{
    if(nPoint >= chromLength)
    {
        PyErr_SetString(geneticError, "n-Point crossover must have n less than chromosomeLength.");
        return False;
    }

    return True;
}

PyMODINIT_FUNC PyInit_geneticOpt(void)
{
    PyObject *m;

    //Verify if types are ready and well defined
    if(PyType_Ready(&realGeneticModelType) < 0)
    {
        return NULL;
    }

    //Create module
    m = PyModule_Create(&geneticOptModule);
    if(m == NULL)
    {
        return NULL;
    }

    //Add the error object to the geneticOpt module
    geneticError = PyErr_NewException("geneticOpt.geneticError", NULL, NULL);
    Py_XINCREF(geneticError);
    if(PyModule_AddObject(m, "geneticError", geneticError) < 0)
    {
        Py_XDECREF(geneticError);
        Py_CLEAR(geneticError);
        Py_DECREF(m);
        return NULL;
    }

    //Add Objects
    Py_INCREF(&realGeneticModelType);
    if(PyModule_AddObject(m, "realCodificationModel", (PyObject *) &realGeneticModelType) < 0)
    {
        Py_DECREF(&realGeneticModelType);
        Py_DECREF(m);
        return NULL;
    }

    return m;
}
