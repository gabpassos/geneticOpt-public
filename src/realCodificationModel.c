#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif
#include <Python.h>
#include "structmember.h"

//USED ONLY IN MODEL VERIFICATION - REMOVE IF VERIFICATION FUNCTIONS ARE MOVED TO A EXCLUSIVE SRC FILE
#include <stdlib.h>
#include <string.h>

#include "realCodificationModel.h"
#include "stdmath.h"
#include "stdgen.h"
#include "realinitialization.h"
#include "realselection.h"
#include "realcrossover.h"
#include "realmutation.h"
#include "realreplacement.h"

static PyMethodDef realGeneticModelMethods[] =
{

    {NULL, NULL, 0, NULL},
};

static PyMemberDef realGeneticModelObjectMembers[] =
{
    {"fitFunction", T_OBJECT, offsetof(realGeneticModelObject, fitFunction), 0,
    "Pointer to a Python fitness function."},

    {"objType", T_NONE, offsetof(realGeneticModelObject, objType), 0,
    "Objective type (minimization or maximization)."},

    {"individual", T_NONE, offsetof(realGeneticModelObject, individual), 0,
    "Individuals of the population generated by the genetic algorithm."},

    {"population", T_NONE, offsetof(realGeneticModelObject, population), 0,
    "Population settings."},

    {"chromosome", T_NONE, offsetof(realGeneticModelObject, chromosome), 0,
    "Chromosome settings."},

    {"initialization", T_NONE, offsetof(realGeneticModelObject, initialization), 0,
    "Initialization model."},

    {"selection", T_NONE, offsetof(realGeneticModelObject, selection), 0,
    "Selection model."},

    {"crossover", T_NONE, offsetof(realGeneticModelObject, crossover), 0,
    "Crossover model."},

    {"mutation", T_NONE, offsetof(realGeneticModelObject, mutation), 0,
    "Mutation model."},

    {"replacement", T_NONE, offsetof(realGeneticModelObject, replacement), 0,
    "Replacement model."},

    {"seed", T_UINT, offsetof(realGeneticModelObject, replacement), 0,
    "Seed used by the random number generator."},

    {NULL},
};

static PyTypeObject realGeneticModelType =
{
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "geneticOpt.realCodificationModel",
    .tp_doc = "Genetic algorithms with real number codification.",
    .tp_basicsize = sizeof(realGeneticModelObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_new = defaultNewRealGeneticModel,
    .tp_init = (initproc) usrInitRealGeneticModel,
    .tp_dealloc = (destructor) realGeneticModelDealloc,
    .tp_methods = realGeneticModelMethods,
    .tp_members = realGeneticModelObjectMembers,
};

static PyModuleDef geneticOptModule =
{
    PyModuleDef_HEAD_INIT,
    .m_name = "geneticOpt",
    .m_doc = "Genetic Algorithms for Python.",
    .m_size = -1,
};

static PyObject * defaultNewRealGeneticModel(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    realGeneticModelObject *self;

    self = (realGeneticModelObject *) type->tp_alloc(type, 0);

    if(self != NULL)
    {
        self->fitFunction = NULL;

        self->objType = undef;

        self->individual = NULL;

        self->population.maxGenerations = 0;
        self->population.size = 0;
        self->population.totalFamilies = 0;
        self->population.totalParents = 0;
        self->population.totalChildren = 0;
        self->population.maxIndividuals = 0;

        self->chromosome.type = real;
        self->chromosome.length = 0;
        self->chromosome.infLimit = NULL;
        self->chromosome.supLimit = NULL;

        self->initialization.type = realInit_type_undef;
        self->initialization.function = NULL;

        self->selection.type = realSelect_type_undef;
        self->selection.function = NULL;
        self->selection.tourModel.function = NULL;
        self->selection.tourModel.tourGroup = NULL;
        self->selection.tourModel.tourSize = 0;

        self->crossover.type = realCross_type_undef;
        self->crossover.function = NULL;
        self->crossover.nPoint = 0;
        self->crossover.prob = 0;
        self->crossover.sepLimits = NULL;

        self->mutation.type = realMut_type_undef;
        self->mutation.function = NULL;
        self->mutation.prob = 0;
        self->mutation.alleleMutProb = 0;
        self->mutation.limit = NULL;

        self->replacement.type = realRepl_type_undef;
        self->replacement.function = NULL;
        self->replacement.srcPopOrdFunction = NULL;

        self->seed = 0;
    }

    return (PyObject *) self;
}

static int usrInitRealGeneticModel(realGeneticModelObject *self, PyObject *args, PyObject *kwds)
{
    char *objStr, *initTypeStr, *selectionTypeStr, *crossoverTypeStr, *mutationTypeStr, *replacementTypeStr;
    PyObject *fitFunction;

    static char *kwlist[] =
    {
        "objective", "fitFunction"
        "maxGenerations", "populationSize", "totalFamilies", "totalParents", "totalChildren",
        "chromosomeLength",
        "initType",
        "selectionType",
        "crossoverType", "crossoverProb",
        "mutationType", "mutationProb", "alleleMutationProb",
        "replacementType",
        NULL
    };



    if(!PyArg_ParseTupleAndKeywords(args, kwds, "|IIIIIIsssdsdds", kwlist,
    &(self->population.maxGenerations), &(self->population.size), &(self->population.totalFamilies), &(self->population.totalParents), &(self->population.totalChildren),
    &(self->chromosome.length),
    &initTypeStr,
    &selectionTypeStr,
    &crossoverTypeStr, &(self->crossover.prob),
    &mutationTypeStr, &(self->mutation.prob), &(self->mutation.alleleMutProb),
    &replacementTypeStr))
    {
        return -1;
    }

    //Set Objective Settings
    if(False)
    {
        return -1;
    }//Fit function and objective type.

    //Set Population settings
    if(!populationModelVerifySettings(&(self->population)))
    {
        return -1;
    }

    //Set Chromosome settings
    if(!chromosomeModelVerifySettings(&(self->chromosome)))
    {
        return -1;
    }

    //Set Init Settings
    if(!realInitializationModelVerifySettings(&(self->initialization), initTypeStr))
    {
        return -1;
    }

    //Set Selection Settings
    if(!realSelectionModelVerifySettings(&(self->selection), selectionTypeStr, &(self->population), self->objType))
    {
        return -1;
    }

    //Set Crossover settings
    if(!realCrossoverModelVerifySettings(&(self->crossover), &(self->chromosome), crossoverTypeStr))
    {
        return -1;
    }

    //Set Mutation Settings
    if(!realMutationModelVerifySettings(&(self->mutation), &(self->chromosome), mutationTypeStr))
    {
        return -1;
    }

    //Set replacement settings
    if(!realReplacementModelVerifySettings(&(self->replacement), replacementTypeStr, self->objType))
    {
        return -1;
    }

    return 0;
}

static void realGeneticModelDealloc(realGeneticModelObject *self)
{

}

static PyObject * realGeneticModelSolver(PyObject *self, PyObject *Py_UNUSED(ignored))
{

}

static boolean populationModelVerifySettings(populationData *population)
{
    if(population->maxGenerations <= 0)
    {
        PyErr_SetString(geneticError, "maxGeneration must be an integer greater than zero.");
        return False;
    }

    else if(population->size <= 0)
    {
        PyErr_SetString(geneticError, "populationSize must be an integer greater than zero.");
        return False;
    }

    else if(population->totalFamilies <= 0)
    {
        PyErr_SetString(geneticError, "totalFamilies must be an integer greater than zero.");
        return False;
    }

    else if(population->totalParents < 2)
    {
        PyErr_SetString(geneticError, "totalParents must be an integer greater than or equal to two.");
        return False;
    }

    else if(population->totalChildren < 2)
    {
        PyErr_SetString(geneticError, "totalChildren must be an integer greater than or equal to two.");
        return False;
    }

    population->maxIndividuals = population->size + (population->totalFamilies)*(population->totalChildren);

    return True;
}

static boolean chromosomeModelVerifySettings(chromosomeData *chromosome)
{
    int i;

    if(chromosome->length <= 0)
    {
        PyErr_SetString(geneticError, "chromosomeLength must be an integer greater than zero.");
        return False;
    }

    chromosome->infLimit = (double *) malloc(chromosome->length*sizeof(double));
    if(chromosome->infLimit == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    chromosome->supLimit = (double *) malloc(chromosome->length*sizeof(double));
    if(chromosome->supLimit == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    for(i = 0; i < chromosome->length; i++)
    {
        chromosome->infLimit[i] = - DEFAULT_CHROM_LIMIT;
        chromosome->supLimit[i] = DEFAULT_CHROM_LIMIT;
    }

    return True;
}

static boolean realInitializationModelVerifySettings(realInitializationModel *initialization, char *initTypeStr)
{
    if(strcmp(initTypeStr, "uniformRandom"))
    {
        initialization->type = realUniformRandomInitType;
        initialization->function = realUniformRandomInit;
    }

    else
    {
        PyErr_SetString(geneticError, "The initType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean realSelectionModelVerifySettings(realSelectionModel *selection, char *selectionTypeStr, populationData *population, objective obj)
{
    if(strcmp(selectionTypeStr, "tournament"))
    {
        if(population->totalParents == 2)
        {
            selection->type = realTwoParentsTournamentSelectionType;
            selection->function = realTwoParentsTournamentSelection;
        }

        else
        {
            selection->type = realnParentsTournamentSelectionType;
            selection->function = realnParentsTournamentSelection;
        }

        selection->tourModel.tourSize = 2;
        selection->tourModel.tourGroup = (int *) malloc(2*sizeof(int));
        if(selection->tourModel.tourGroup == NULL)
        {
            PyErr_NoMemory();
            return False;
        }

        if(obj == min)
        {
            selection->tourModel.function = minTournament;
        }

        else
        {
            selection->tourModel.function = maxTournament;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The selectionType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean realCrossoverModelVerifySettings(realCrossoverModel *crossover, chromosomeData *chromosome, char *crossoverTypeStr)
{
    int i;
    double ratio;

    if(crossover->prob < 0 || crossover->prob > 1)
    {
        PyErr_SetString(geneticError, "The crossoverProb must be a double in the [0,1] interval.");
        return False;
    }

    if(strcmp(crossoverTypeStr, "1-Point"))
    {
        crossover->type = realOnePointCrossoverType;
        crossover->function = realOnePointCrossover;
        crossover->nPoint = 1;

        if(!verifyChromLengthWithnPoint(chromosome->length, 1))
        {
            return False;
        }
    }

    else if(strcmp(crossoverTypeStr, "2-Point"))
    {
        crossover->type = realTwoPointCrossoverType;
        crossover->function = realTwoPointCrossover;
        crossover->nPoint = 2;

        if(!verifyChromLengthWithnPoint(chromosome->length, 2))
        {
            return False;
        }
    }

    else if(strcmp(crossoverTypeStr, "3-Point"))
    {
        crossover->type = realThreePointCrossoverType;
        crossover->function = realThreePointCrossover;
        crossover->nPoint = 3;

        if(!verifyChromLengthWithnPoint(chromosome->length, 3))
        {
            return False;
        }
    }

    else if(strcmp(crossoverTypeStr, "n-Point"))
    {
        crossover->type = realnPointCrossoverType;
        crossover->function = realnPointCrossover;
        crossover->nPoint = 4;

        if(!verifyChromLengthWithnPoint(chromosome->length, 4))
        {
            return False;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The crossoverType provided cannot be recognized.");
        return False;
    }

    crossover->sepLimits = (double **) malloc((crossover->nPoint)*sizeof(double *));
    if(crossover->sepLimits == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    ratio = (chromosome->length)/(crossover->nPoint);

    for(i = 0; i < crossover->nPoint; i++)
    {
        crossover->sepLimits[i] = (double *) malloc(2*sizeof(double));

        if(crossover->sepLimits[i] == NULL)
        {
            PyErr_NoMemory();
            return False;
        }

        crossover->sepLimits[i][0] = (unsigned int) i*ratio;
        crossover->sepLimits[i][1] = (unsigned int) (i + 1)*ratio;
    }

    return True;
}

static boolean realMutationModelVerifySettings(realMutationModel *mutation, chromosomeData *chromosome, char *mutationTypeStr)
{
    int i;

    if(mutation->prob < 0 || mutation->prob > 1)
    {
        PyErr_SetString(geneticError, "The mutationProb must be a double in the [0,1] interval.");
        return False;
    }

    if(mutation->alleleMutProb < 0 || mutation->alleleMutProb > 1)
    {
        PyErr_SetString(geneticError, "The alleleMutProb must be a double in the [0,1] interval.");
        return False;
    }

    mutation->limit = (double **) malloc((chromosome->length)*sizeof(double *));
    if(mutation->limit == NULL)
    {
        PyErr_NoMemory();
        return False;
    }

    for(i = 0; i < chromosome->length; i++)
    {
        mutation->limit[i] = (double *) malloc(2*sizeof(double));
        if(mutation->limit[i] == NULL)
        {
            PyErr_NoMemory();
            return False;
        }
    }

    if(strcmp(mutationTypeStr, "totalUniformRandom"))
    {
        mutation->type = realTotalUniformRandomMutationType;
        mutation->function = realTotalUniformRandomMutation;

        for(i = 0; i < chromosome->length; i++)
        {
            mutation->limit[i][0] = - DEFAULT_CHROM_LIMIT;
            mutation->limit[i][1] = DEFAULT_CHROM_LIMIT;
        }
    }

    else if(strcmp(mutationTypeStr, "uniformRandom"))
    {
        mutation->type = realUniformRandomMutationType;
        mutation->function = realUniformRandomMutation;

        for(i = 0; i < chromosome->length; i++)
        {
            mutation->limit[i][0] = - DEFAULT_UNIFORMMUT_LIMIT;
            mutation->limit[i][1] = DEFAULT_UNIFORMMUT_LIMIT;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The mutationType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean realReplacementModelVerifySettings(realReplacementModel *replacement, char *replacementTypeStr, objective obj)
{
    if(strcmp(replacementTypeStr, "elitist"))
    {
        replacement->type = realElitistReplacementType;
        replacement->function = realElitistReplacement;

        if(obj == min)
        {
            replacement->srcPopOrdFunction = realMinimizationCompare;
        }

        else
        {
            replacement->srcPopOrdFunction = realMaximizationCompare;
        }
    }

    else
    {
        PyErr_SetString(geneticError, "The replacementType provided cannot be recognized.");
        return False;
    }

    return True;
}

static boolean verifyChromLengthWithnPoint(unsigned int chromLength, unsigned int nPoint)
{
    if(nPoint >= chromLength)
    {
        PyErr_SetString(geneticError, "n-Point crossover must have n less than chromosomeLength.");
        return False;
    }

    return True;
}

PyMODINIT_FUNC PyInit_geneticOpt(void)
{
    PyObject *m;

    //Verify if types are ready and well defined
    if(PyType_Ready(&realGeneticModelType) < 0)
    {
        return NULL;
    }

    //Create module
    m = PyModule_Create(&geneticOptModule);
    if(m == NULL)
    {
        return NULL;
    }

    //Add the error object to the geneticOpt module
    geneticError = PyErr_NewException("geneticOpt.geneticError", NULL, NULL);
    Py_XINCREF(geneticError);
    if(PyModule_AddObject(m, "geneticError", geneticError) < 0)
    {
        Py_XDECREF(geneticError);
        Py_CLEAR(geneticError);
        Py_DECREF(m);
        return NULL;
    }

    //Add Objects
    Py_INCREF(&realGeneticModelType);
    if(PyModule_AddObject(m, "realCodificationModel", (PyObject *) &realGeneticModelType) < 0)
    {
        Py_DECREF(&realGeneticModelType);
        Py_DECREF(m);
        return NULL;
    }
}
